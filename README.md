# ![Spring logo](https://github.com/InsaneDan/InsaneDan/blob/main/spring.png)

## 1. Основы Java EE
<details>
<summary>Обзор Java EE-компонентов и введение в web-технологии. Что такое сервлеты. Слушатели. Фильтры.</summary>
  
1. Установить сервер приложений TomCat или Wildfly (либо любой другой по выбору);
2. Создать и запустить новый проект по инструкции из данной методички.
3. Создайте класс Product с полями (id, title, cost).
4. Реализуйте сервлет выводящий на страницу список из 10 продуктов (создаете продукты в момент обработки запроса).

Сервер приложений: WildFly-23.0.0.Final (старт сервера через stanalone.bat)
Реализация: HttpServlet + JSP (± подобие JPA, т.к. нет подключения к БД)
Для установки на сервер приложений - Run Maven goal: clean install wildfly:deploy

URL: http://127.0.0.1:8080/webapp/http-servlet - основные методы HttpServlet  
URL: http://127.0.0.1:8080/webapp/product - список продуктов
<details>
<summary>Комментарии</summary>
  
- Дескриптор развертывания. Файл web.xml содержит только служебную информацию, маппинг не прописан (используются аннотации @WebServlet(urlPatterns = "..."))
- Вывод списка продуктов: сервлет наследуется от HttpServlet, представление (persistence) - вынесено в отдельные классы (продукт и репозиторий). Для задания испольуются методы только для сохранения и получения списка продуктов из репозитория.
- Список продуктов для репозитория создается при инициализации сервлета (срабатывает ServletContextListener).
- Вывод страницы на сервере приложений с помощью JSP. При формировании страницы импортируется <head> и <navbar> из отдельных jsp-файлов. Страницы созданы с использованием css Bootstrap v4.3.
- SimpleHttpServlet - формирует html-текст для отображения страницы (HttpServletResponse) "вручную", страница содержит основные методы класса.
</details>
</details>

## 2. Введение в Spring
<details>
<summary>Введение в Spring. Dependency Injection и Inversion of Control. Бины. Spring Context. Конфигурирование.</summary>
  
1. Есть класс Product (id, название, цена). Товары хранятся в бине ProductRepository, в виде List<Product>, при старте в него нужно добавить 5 любых товаров.
2. ProductRepository позволяет получить весь список или один товар по id. Создаем бин Cart, в который можно добавлять и удалять товары по id.
3. Написать консольное приложение, позволяющее управлять корзиной.
4. При каждом запросе корзины из контекста, должна создаваться новая корзина.
<details>
<summary>Комментарии</summary>

- компонент ProductRepository - является singletone; Cart - @Scope("prototype");
- наполнение productRepository товарами после создания бина (@PostConstruct);
- корзина в виде Map: ключ - продукты, значение - количество продукта в корзине;
- в CartServiceImpl использована аннотация @Autowired для метода setProductRepository. По большому счету внедрение продуктового репозитория в корзину не требуется - экспериментировал с @Autowired.
- для запуска - DemoApp.
</details>
</details>

## Урок 3. Spring MVC
<details>
<summary>Spring MVC. Контроллеры. Работа с формами. Представления. Конфигурирование Spring MVC. Контекст Spring MVC.</summary>
  
1. Разобраться с примером проекта на Spring MVC.
2. Создать класс Товар (Product), с полями id, title, cost.
3. Товары необходимо хранить в репозитории (класс, в котором в виде List<Product> хранятся товары). Репозиторий должен уметь выдавать список всех товаров и товар по id.
4. Сделать форму для добавления товара в репозиторий и логику работы этой формы.
5. Сделать страницу, на которой отображаются все товары из репозитория.
<details>
<summary>Комментарии</summary>

* Просмотр сведений о продукте, добавление нового продукта и редактирование существующего сделано в одной форме. ID продукта,
  если он есть, указывается в скрытом элементе формы.

    - Получение товара по id (только просмотр): GET запрос с параметрами view=1 и id, при отображении страницы - все поля
  формы disable (нельзя изменить, нельзя навести фокус, нельзя отправить).
    - Для редактирования сведений о товаре - GET запрос с указанием id; для сохранения изменений - POST ответ, список
  продуктов (HashMap) пересохраняет данные по ключу (id).
    - Для создания нового товара - GET без указания id; при сохранении данных (POST) подбирается новый id (= максимальный +
  1).

* После сохранения товара в репозитории @PostMapping("/edit/save") из формы редактирования выполняется редирект на
  страницу со списком продуктов.
* Удаление товара из репозитория @GetMapping("/delete"). После удаления выполняется редирект на эту же страницу со
  списком товаров (в идеале - сделать обновление только таблицы, а не всей страницы целиком).
* Контроллеры для корзины, контактов, главной страницы - пустые, содержат только маппинг, оставлены для перехода на
  соответствующие страницы.
* Неправильное отображение кириллицы - исправлено.
* Деплой и проверка на Tomcat 9.0 и Wildfly 23.0.0.

THYMELEAF
1. Шаблон default.html с разметкой для блоков <head>, <header> (панель навигации), <footer> (включает скрипты jquery и
   jsdelivr для элементов и разметки bootstrap). Блоки из шаблона переиспользуются на других страницах.
2. В разных вариациях использованы переменные ${...}, элементы списков *{...}, сообщения #{...}, ссылки @{...},
   фрагменты ~{...}
3. Форматирование чисел - в таблице товаров приведены к виду 0.00.
4. Циклы - нумерация строк в таблице товаров, повторение абзацев на главной странице.
5. Динамический выбор текста на элементах формы (Создать / Сохранить при изменении данных о товаре), отключение полей формы, .

Недоделано:
* Обновить таблицу (список продуктов) без перезагрузки страницы. В JSP и JPF для ajax'ов есть спец.тэг, в thymeleaf'е не
разобрался, как это сделать. 
* Добавление класса "active" (th:classappend) к элементам меню навигации. Меню добавляется из шаблона, который не обрабатывается ни одним из контроллеров. Передать в него аттрибут напрямую нельзя. Простого решения не нашел.
</details>
</details>

## Урок 4. Spring MVC
<details>
<summary>Spring MVC. Контроллеры. Работа с формами. Представления. Конфигурирование Spring MVC. Контекст Spring MVC.</summary>
  
1. Перенести функциональность, реализованную на прошлом занятии, на платформу Spring Boot.
<details>
<summary>Комментарии</summary>

Миграция в Spring Boot. Дополнения к проекту:
* Добавлено отображение активной страницы в меню навигации (передача параметра во фрагмент, содержащий меню, в зависимости от значения добавление класса th:classappend="active"). Т.к. меню присутствует на всех страницах, в контроллеры добавлены дефолтные методы с аннотацией @ModelAttribute("activePage").
* Добавлена страница со списком товаров в корзине, ценой, суммарной стоимостью.
* Добавление и удаление товаров в корзину на странице списка товаров, изменение количества (увеличить / уменьшить) в корзине.
* Товары в корзине выводятся с сортировкой по названию (в сервисе хранится HashMap на отображение отдается ArrayList)
* Изменена логика удаления товаров - добавление отрицательного количества продуктов; если количество становится <=0, то продукт удаляется из корзины.
* При добавлении/удалении товара в корзину, при переходе на страницу с описанием товара из корзины или из списка товаров для редиректа и  возврата на страницу, с которой был вызван маппинг, использован заголовок "referer" HttpServletRequest.
* Просмотр информации о продукте по клику на название (и в списке товаров, и в корзине), возврат обратно на "свою" страницу.

Недоделано:
* передать общее количество товаров в бэйдж корзины, который находится во фрагменте меню (работает только на странице корзины).
</details>
</details>

## Урок 5. Java Persistence API. Hibernate. Часть 1
<details>
<summary>Java Persistence API. Hibernate. Понятие сущности. Объектно-реляционное отображение. Контекст постоянства (Persistence Context). Менеджер сущностей. Доступ к атрибутам.</summary>
  
1. Создайте сущность Product (Long id, String title, int price) и таблицу в базе данных для хранения объектов этой сущности;
2. Создайте класс ProductDao и реализуйте в нем логику выполнения CRUD-операций над сущностью Product (Product findById(Long id), List"Product" findAll(), void deleteById(Long id), Product saveOrUpdate(Product product)).
<details>
<summary>Комментарии</summary>

* **Настройкa hibernate**: 1) через конфигурационный класс PersistenceConfig; 2) через hibernate.cfg.xml (закомментирован); 3) через application.properties (закомментировано, требуется Spring Data).
* **Проверено на СУБД**: MySQL и PostgreSQL.
* **Реализация запросов:**
  
  * в основном NamedQuery (показались наиболее удобными);
  * другие варианты – закоментированы в методе *findAllSortedByName* (JPQL Query, NativeQuery, Criteria API - простой поиск+сортировка) и *findById* (find как пример реализации CRUD-операции read).
</details>
</details>

## Урок 6. Java Persistence API / Hibernate. Часть 2
<details>
<summary>Отображение связей. Каскадные операции. Продвинутые вопросы работы с Hibernate</summary>
  
1. В базе данных необходимо реализовать возможность хранить информацию о покупателях (id, имя) и товарах (id, название, стоимость). У каждого покупателя свой набор купленных товаров.
2. Для обеих сущностей создаете Dao классы. Работу с SessionFactory выносите во вспомогательный класс;
3. Создаете сервис, позволяющий по id покупателя узнать список купленных им товаров, и по id товара узнавать список покупателей этого товара;
4. ** Добавить детализацию по паре «покупатель — товар»: сколько стоил товар в момент покупки клиентом;

**ВАЖНО И ОБЯЗАТЕЛЬНО!** Dao классы и сервис должны являться Spring бинами (Вам нужен Spring Context без веб части). Контроллеры создавать не надо.  
**ВАЖНО!** Выкидываете код по подготовке данных и таблиц, и делаете отдельный скрипт и формируете базу заранее. Покупателей и товары в базу складываете заранее, через код этого делать не надо (лишнее усложнение). SQL-скрипт прикрепите к работе.
<details>
<summary>Комментарии</summary>

консольный вариант - отдельным бином (Lesson06HW)
</details>
</details>

## Урок 7. Spring Data
<details>
<summary>DAO. Spring Data JPA. Сервис-уровень.</summary>

1. Создать сущность «Товар» (id, название, стоимость) и соответствующую таблицу в БД. Заполнить таблицу тестовыми данными (20 записей).
2. Сделать RestController позволяющий выполнять следующий набор операции над этой сущностью:  
  получение товара по id [ GET .../app/products/{id} ]  
  получение всех товаров [ GET .../app/products ]  
  создание нового товара [ POST .../app/products ]  
  удаление товара по id.[ GET .../app/products/delete/{id} ]  
(**Замечание**: пока делаем немного не по правилам REST API, эта тема будет разбираться на следующих занятиях, поэтому удаление выполняется через http-метод GET, а не DELETE)
3. *К запросу всех товаров добавьте возможность фильтрации по минимальной и максимальной цене (в трех вариантах: товары дороже min цены, товары дешевле max цены, или товары, цена которых находится в пределах min-max).
<details>
<summary>Комментарии</summary>

* реализация через SpringDataApplication с использованием интерфейса CommandLineRunner (stdOut)
* разбивка списка продуктов на страницы
* web-слой не подключен!
</details>
</details>

## Урок 8. Thymeleaf
<details>
<summary>Шаблонизатор Thymeleaf. Интеграция с фреймворком Spring. Выражения. Операторы.</summary>

1. Сделайте страницу для отображения всех товаров.
2. Рядом с каждым товаром в таблице попробуйте сделать кнопку "Удалить", при нажатии на которую товар должен быть удален и базы.
3. *Попробуйте реализовать разбивку всех товаров на страницы, по 10 товаров на каждой.
<details>
<summary>Комментарии</summary>

* удаление / добавление / редактирование товаров с сохранением результатов в БД (коррекция того, что было сделано на уроке Spring MVC);
* количество товаров в бейдже корзины (фрагмент header) отображается на всех страницах, реализация за счет прямого обращения к синглтон-бину из шаблона;  
* пример работы DateFormatter на странице index.html
* пагинация списка товаров и меню для перемещения по страницам.  
  Полный список товаров на одной странице по индексу = 0 (...localhost:8081/app/products/0).
* фильтр по минимальной и максимальной цене, по части названия товара (с сохранением навигации по страницам).  
  Для работы с формой через Thymeleaf создан доп.класс с соответствующими полями (ProductFilter).
  В рабочем коде оставлен method="get", т.к. не требует дополнительной точки в контроллере, post - закомментирован.  
  * через GET-запрос в "основной" эндпоинт @GetMapping({"", "/{pageIndex}"}):  
    ...localhost:8081/app/products/1?minPrice=0&maxPrice=1000000&partName=&productsPerPage=5  
  * через POST-запрос в дополнительный эндпоинт @PostMapping("/filter"), в котором заполняются атрибуты и делается редирект на
    @GetMapping({"", "/{pageIndex}"}).

– т.к. изменилась логика работы корзины, то товары не суммируются, а каждый экземпляр достается из репозитория и сохраняется отдельно.
В последующих уроках будет реализован REST-контроллер корзины, поэтому пока не исправлено.
</details>
</details>

## Урок 9. Spring REST. Часть 1
<details>
<summary>Spring REST. HTTP 1.1. CRUD-операции.</summary>

1. Реализуйте REST контроллер для работы с сущностью Product;
<details>
<summary>Комментарии</summary>

* настройка приложения через application.yaml.
* использована H2, развернутая in memory (jdbc:h2:mem:test). Для миграции БД добавлена зависимость Flywaydb, развертывание базы скриптом из файла "resources\db\migration\V1__init.sql". 
* для тестирования REST-запросов добавлен Swagger2.
* Эндпоинты:  
  -  GET - постраничный список товаров (с фильтром по цене и названию товара - @RequestParam); возвращает страницу со списком товаров либо HttpStatus.BAD_REQUEST(400), если список пустой.
  -  GET - получить товар по id (@PathVariable); возвращает товар, если он найден, в противном случае - 404.
  -  POST - добавление товара, PUT - изменение. Т.к. оба метода реализованы через CRUD операцию save(product), то выполняется проверка, чтобы исключить "неправильное" применение. Изменение данных через post и добавление через put возвращает ошибку UNAVAILABLE_FOR_LEGAL_REASONS(451).
  -  DELETE - удаление по id - если товар не найден, возвращается статус NOT_FOUND(404), при успешном удалении возвращается NO_CONTENT(204);
* Т.к. при работе с некоторыми приложениями для работы с REST API (проверял на SoapUI и Postman) возникала ошибка, связанная с неправильным указанием типа контента (вместо contentType:"application/json" отправлял "application/text"), то в аннотацию добавил принудительное преобразование MediaType.APPLICATION_JSON_VALUE. В Swagger значение "application/json" задано по умолчанию.
</details>
</details>

## Урок 10. Spring REST. Часть 2
<details>
<summary></summary>
  
Комментарии:

</details>

## Урок 11. Spring Security
<details>
<summary></summary>
  

Комментарии:

</details>

## Урок 12. Практика
<details>
<summary></summary>
  

Комментарии:

</details>
